---
title: 面试系列（五）| JVM垃圾回收算法
tags: 
  - 面试
  - JVM
  - 垃圾回收
categories:
  - 面试
  - JVM
  - 垃圾回收算法
summary: JAVA程序员必练的内功心法
cover: https://s2.loli.net/2024/12/20/sL5EIGAYVDUuH6a.jpg
abbrlink: 10871
date: 2021-10-13 19:00:00
---
JVM 分代收集理论有哪些？
------------------------

> 强分代：新生代和老年代
>
> 弱分代：新生代和老年代
>
> 跨代引用：记忆集【有跨代（dirty）、无跨带（clean）】

### 分代收集

- **强分代假说**：强分代假说指的是 `JVM` 认为绝大多数对象的生存周期都是朝生夕灭的；
- **弱分代假说**：弱分代假说指的是只要熬过越多次垃圾收集过程的对象就越难以回收（看来对象也会长心眼）。

```
就是基于这两个假说理论，
```

`JVM` 将**堆区**划分为不同的区域，再将需要回收的对象根据其**熬过垃圾回收的次数**分配到不同的区域中存储。

```
```

`JVM` 根据这两条分代收集理论把**堆区**划分

- 新生代 (`Young` `Generation`) ：每次垃圾收集时都发现有大批对象死去
- 老年代 (`Old` `Generation`)：剩下没有死去的对象会直接晋升到老年代中

  ### 跨代引用

```
上面这两个假说
```

**没有考虑对象的引用关系**，而事实情况是，对象之间会存在引用关系，基于此又诞生了

- **跨代引用假说 (Intergeneration Reference Hypothesis)**，跨代引用相比较同代引用来说仅占少数。正常来说存在相互引用的两个对象应该是**同生共死**的，不过也会存在特例。

```
如果一个新生代对象跨代引用了一个老年代的对象，那么垃圾回收的时候就不会回收这个新生代对象，更不会回收老年代对象，然后这个新生代对象熬过一次垃圾回收进入到老年代中，这时候跨代引用才会消除。
```


```
根据跨代引用假说，我们不需要因为老年代中存在
```

**少量跨代引用**就去直接扫描**整个老年代**，也不用在老年代中维护一个列表记录有哪些跨代引用，实际上，可以直接在新生代中维护一个**记忆集 (Remembered Set)**，由这个记忆集把老年代划分称为**若干小块**，标识出老年代的哪一块会存在**跨代引用**。

![](https://s2.loli.net/2024/12/20/dVqRNWhzC58eHQM.jpg)

```
从图中我们可以看到，记忆集中的每个元素分别对应内存中的一块
```

**连续区域是否有跨代引用对象**，如果有，该区域会被标记为 “脏的”（`dirty`），否则就是 “干净的”（`clean`）。这样在垃圾回收时，只需要扫描记忆集就可以简单地确定跨代引用的位置，是个典型的空间换时间的思路。

JVM 中的垃圾回收算法？
----------------------

> 在聊具体的垃圾回收算法之前，需要明确一点，哪些对象需要被垃圾收集器进行回收？也就是说需要先判断哪些对象是 "垃圾"？
> 清除算法（内存碎片问题）、复制算法（空间浪费）、整理算法（整理出连续的可用内存）

```
判断的标准我在上面
```

**如何判断对象已经死亡**的问题中描述了，有两种方式，一种是**引用计数法**，这种判断标准就是给对象添加一个引用计数器，引用这个对象会使计数器的值 **+ 1**，引用失效后，计数器的值就会 **-1**。但是这种技术无法解决对象之间的**循环引用问题**。

还有一种方式是 `GC Roots`，`GC Roots` 这种方式是以 `Root` 根节点为核心，逐步向下搜索每个对象的引用，搜索走过的路径被称为引用链，如果搜索过后这个对象不存在引用链，那么这个对象就是无用对象，可以被回收。`GC Roots` 可以解决循环引用问题，所以一般 `JVM` 都采用的是这种方式。

解决循环引用代码描述：

```java
public class test{
    public static void main(String[]args){
        A a = new A();
        B b = new B();
        a=null;
        b=null;
    }
}
class A {
 
    public B b;
}
class B {
    public A a;
}
```

基于 `GC Roots` 的这种思想，发展出了很多垃圾回收算法，下面我们就来聊一聊这些算法。

### 标记 - 清除算法

```
标记 - 清除 (
```

`Mark-Sweep`) 这个算法可以说是最早最基础的算法了。

```
标记 - 清除顾名思义分为两个阶段，即
```

**标记**和**清除**阶段：

- 首先标记出所有需要回收的对象，在标记完成后，统一**回收掉所有被标记**的对象。
- 当然也可以标记存活的对象，回收未被标记的对象。这个标记的过程就是**垃圾判定**的过程。

后续大部分垃圾回收算法都是基于标记 - 算法思想衍生的，只不过后续的算法弥补了标记 - 清除算法的缺点，那么它有什么**缺点**呢？主要有两个

* **执行效率不稳定**：因为假如说堆中存在大量无用对象，而且大部分需要回收的情况下，这时必须进行大量的标记和清除，导致标记和清除这两个过程的执行效率随对象的数量增长而降低。
* **内存碎片化**：标记 - 清除算法会在堆区产生大量不连续的内存碎片。碎片太多会导致在分配大对象时没有足够的空间，不得不进行一次垃圾回收操作。

标记算法的示意图如下

![](https://s2.loli.net/2024/12/20/WcCTsNxHB2R5Lbo.jpg)

### 标记 - 复制算法

```
由于标记 - 清除算法极易产生内存碎片，研究人员提出了标记 - 复制算法，标记 - 复制算法也可以简称为
```

**复制算法**，复制算法是一种**半区复制**，它会将内存大小划分为相等的两块，每次只使用其中的一块，用完一块再用另外一块，然后再把用过的一块进行清除。虽然解决了部分内存碎片的问题，但是复制算法也带来了新的问题，即**复制开销**，不过这种开销是可以降低的，如果内存中大多数对象是无用对象，那么就可以把少数的存活对象进行复制，再回收无用的对象。

```
不过复制算法的缺陷也是显而易见的，那就是
```

**内存空间缩小为原来的一半**，**空间浪费**太明显。标记 - 复制算法示意图如下

![](https://s2.loli.net/2024/12/20/XVRLqxNjO3JlwK8.jpg)

```
现在
```

`Java` 虚拟机大多数都是用了这种算法来回收新生代，因为经过研究表明，新生代对象 `98%` 都熬不过第一轮收集，因此不需要按照 1 ：1 的比例来划分新生代的内存空间。

```
基于此，研究人员提出了一种
```

`Appel` 式回收，`Appel` 式回收的具体做法是把新生代分为一块较大的 _`Eden`_ 空间和两块 _`Survivor`_ 空间，每次分配内存都只使用 `Eden` 和其中的一块 `Survivor` 空间，发生垃圾收集时，将 `Eden` 和 `Survivor` 中仍然存活的对象一次性复制到另外一块 `Survivor` 空间上，然后直接清理掉 `Eden` 和已使用过的 `Survivor` 空间。

```
在主流的
```

`HotSpot` 虚拟机中，默认的 `Eden` 和 `Survivor` 大小比例是 `8：1`，也就是每次新生代中可用内存空间为整个新生代容量的 `90%`，只有一个 `Survivor` 空间，所以会浪费掉 `10%` 的空间。这个 `8：1` 只是一个理论值，也就是说，不能保证每次都有不超过 `10%` 的对象存活，所以，当进行垃圾回收后如果 `Survivor` 容纳不了可存活的对象后，就需要其他内存空间来进行**帮助**，这种方式就叫做**内存担保 (Handle Promotion)** ，通常情况下，作为担保的是老年代。

### 标记 - 整理算法

```
标记 - 复制算法虽然解决了内存碎片问题，但是没有解决复制对象存在大量开销的问题。为了解决复制算法的缺陷，充分利用内存空间，提出了标记 - 整理算法。该算法标记阶段和标记 - 清除一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。具体过程如下图所示：
```


![](https://s2.loli.net/2024/12/20/GILHZhe4BEJRvsr.jpg)

什么是记忆集，什么是卡表？记忆集和卡表有什么关系？
--------------------------------------------------

```
为了解决跨代引用问题，提出了记忆集这个概念，记忆集是一个在新生代中使用的数据结构，它相当于是记录了一些
```

**指针的集合**，指向了老年代中哪些对象存在跨代引用。

```
记忆集的实现有不同的粒度
```


* **字长精度**：每个记录精确到一个字长，机器字长就是处理器的寻址位数，比如常见的 32 位或者 64 位处理器，这个精度决定了机器访问物理内存地址的指针长度，字中包含跨代指针。
* **对象精度**：每个记录精确到一个对象，该对象里含有跨代指针。
* **卡精度**：每个记录精确到一块内存区域，区域内含有跨代指针。

  其中卡精度是使用了卡表作为记忆集的实现，关于记忆集和卡表的关系，大家可以想象成是 HashMap 和 Map 的关系。

什么是卡页？
------------

卡表其实就是一个字节数组

```java
CARD_TABLE[this address >> 9] = 0;
```

```
字节数组
```

`CARD_TABLE` 的每一个元素都对应着内存区域中一块特定大小的内存块，这个内存块就是**卡页**，一般来说，卡页都是 2 的 N 次幂字节数，通过上面的代码我们可以知道，卡页一般是 2 的 9 次幂，这也是 `HotSpot` 中使用的卡页，即 512 字节。

```
一个卡页的内存通常包含不止一个对象，只要卡页中有一个对象的字段存在跨代指针，那就将对应卡表的数组元素的值设置为 1，称之为这个元素变
```

`脏`了，没有标示则为 0 。在垃圾收集时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，然后把他们加入 `GC Roots` 进行扫描。

所以，卡页和卡表主要用来解决跨代引用问题的。

什么是写屏障？写屏障带来的问题？
--------------------------------

### 写屏障

```
如果有其他分代区域中对象引用了本区域的对象，那么其对应的卡表元素就会变脏，这个引用说的就是对象赋值，也就是说卡表元素会变脏发生在对象赋值的时候，那么如何在对象赋值的时候更新维护卡表呢？
```


在 `HotSpot` 虚拟机中使用的是**写屏障 (Write Barrier)** 来维护卡表状态的，这个写屏障和我们内存屏障完全不同，希望读者不要搞混了。

```
这个写屏障其实就是一个
```

`Aop` 切面，在引用对象进行赋值时会产生一个**环形通知 (Around)**，环形通知就是切面前后分别产生一个通知，因为这个又是写屏障，所以在赋值前的部分写屏障叫做写前屏障，在赋值后的则叫做写后屏障。

### 写屏障会带来两个问题

#### **无条件写屏障带来的性能开销**

```
每次对引用的更新，无论是否更新了老年代对新生代对象的引用，都会进行一次写屏障操作。显然，这会增加一些额外的开销。
```


```
但是，扫描整个老年代相比较，这个开销就低得多了。
```


```
不过，在高并发环境下，写屏障又带来了伪共享（
```

`false sharing`）问题。

#### **高并发下伪共享带来的性能开销**

```
在高并发情况下，频繁的写屏障很容易发生伪共享（
```

`false sharing`），从而带来性能开销。

```
假设
```

`CPU` 缓存行大小为 64 字节，由于一个卡表项占 1 个字节，这意味着，64 个卡表项将共享同一个缓存行。

```
```

`HotSpot` 每个卡页为 512 字节，那么一个缓存行将对应 64 个卡页一共 `64*512 = 32KB`。

```
如果不同线程对对象引用的更新操作，恰好位于同一个 32 KB 区域内，这将导致同时更新卡表的同一个缓存行，从而造成缓存行的写回、无效化或者同步操作，间接影响程序性能。
```


```
一个简单的解决方案，就是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表项未被标记过才将其标记为脏的。
```


```
这就是
```

`JDK  7` 中引入的解决方法，引入了一个新的 JVM 参数 `-XX:+UseCondCardMark`，在执行写屏障之前，先简单的做一下判断。如果卡页已被标识过，则不再进行标识。

简单理解如下：

```java
if (CARD_TABLE [this address >> 9] != 0)
  CARD_TABLE [this address >> 9] = 0;
```

```
与原来的实现相比，只是简单的增加了一个判断操作。
```


```
虽然开启
```

`-XX:+UseCondCardMark` 之后多了一些判断开销，但是却可以避免在高并发情况下可能发生的并发写卡表问题。

```
通过减少并发写操作，进而避免出现伪共享问题（
```

`false sharing`）。

什么是三色标记法？三色标记法会造成哪些问题？
--------------------------------------------

> 白色：可回收、灰色：还未访问完毕、黑色：已访问

### 三色标记法

```
根据可达性算法的分析可知，如果要找出存活对象，需要从
```

`GC Roots` 开始遍历，然后搜索每个对象是否可达，如果对象可达则为存活对象，在 GC Roots 的搜索过程中，按照**对象和其引用是否被访问过**这个条件会分成下面三种颜色：

* **白色**：白色表示 `GC Roots` 的遍历过程中没有被访问过的对象，出现白色显然在可达性分析刚刚开始的阶段，这个时候所有对象都是白色的，如果在分析结束的阶段，仍然是白色的对象，那么代表不可达，可以**进行回收**。
* **灰色**：灰色表示对象已经**被访问过，**但是这个对象的引用还**没有访问完毕**。
* **黑色**：黑色表示此对象已经被访问过了，而且这个对象的引用也已经被访问了。

> 注：如果标记结束后对象仍为白色，意味着已经 “找不到” 该对象在哪了，不可能会再被重新引用。

```
现代的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同：
```


- 白色 / 黑色集合一般都不会出现（但是有其他体现颜色的地方）
- 灰色集合可以通过**栈 / 队列 / 缓存日志**等方式进行实现、遍历方式可以是广度 / 深度遍历等等。

### 造成问题

```
三色标记法会造成
```

**两种问题**，这两种问题所出现的环境都是由于【**用户环境】和【收集器并行工作】造成的** 。

```
当用户线程正在修改引用关系，此时收集器在回收引用关系，此时就会造成把原本已经消亡的对象标记为存活，如果出现这种状况的话，问题不大，下次再让收集器重新收集一波就完了，但是还有一种情况是把存活的对象标记为死亡，这种状况就会造成不可预知的后果。
```


```
针对上面这两种对象消失问题，业界有两种
```

**处理方式**，

- **增量更新 (Incremental Update)** ，
- **原始快照 (Snapshot At The Beginning, SATB)**。

请你介绍一波垃圾收集器
----------------------

```
垃圾收集器是面试的常考，也是必考点，只要涉及到
```

`JVM` 的相关问题，都会围绕着垃圾收集器来做一波展开，所以，有必要了解一下这些垃圾收集器。

```
垃圾收集器有很多，不同商家、不同版本的 JVM 所提供的垃圾收集器可能会有很大差别，我们主要介绍
```

`HotSpot` 虚拟机中的垃圾收集器。

```
垃圾收集器是垃圾回收算法的具体实现，我们上面提到过，垃圾回收算法有
```

**标记 - 清除算法**、**标记 - 复制**、**标记 - 整理**，所以对应的垃圾收集器也有不同的实现方式。

```
我们知道，
```

`HotSpot` 虚拟机中的垃圾收集都是分代回收的，所以根据不同的分代，可以把垃圾收集器分为

- 新生代收集器：`Serial、ParNew、Parallel Scavenge`
- 老年代收集器：`Serial Old、Parallel Old、CMS`
- 整堆收集器：`G1`

### Serial 收集器（新生|复制算法|单线程）

`Serial` 收集器是一种**新生代的垃圾收集器**，它是一个**单线程**工作的收集器，使用**复制算法**来进行回收，单线程工作不是说这个垃圾收集器只有一个，而是说这个收集器在工作时，必须暂停其他所有工作线程，这种暴力的暂停方式就是 **`Stop The World`**，Serial 就好像是寡头垄断一样，只要它一发话，其他所有的小弟（线程）都得给它让路。`Serial` 收集器的示意图如下：

![](https://s2.loli.net/2024/12/20/XMh2GiZEJH4sRau.jpg)

```
虽然
```

`Serial` 有 `STW` 这种显而易见的缺点，不过，从其他角度来看，`Serial` 还是很讨喜的，它还有着优于其他收集器的地方，那就是简单而高效，对于内存资源首先的环境，它是所有收集器中额外内存消耗最小的，对于单核处理器或者处理器核心较少的环境来说，`Serial` 收集器由于没有线程交互开销，所以 `Serial` 专心做垃圾回收效率比较高。

### SefePoint 全局安全点

```
它就是代码中的一段特殊的位置，在所有用户线程到达
```

`SafePoint` 之后，用户线程挂起，GC 线程会进行清理工作。

### ParNew 收集器（新生|复制算法|多线程）

```
```

`ParNew` 是 `Serial` 的多线程版本，除了同时使用多条线程外，其他参数和机制（**STW、回收策略、对象分配规则**）都和 `Serial` 完全一致，`ParNew` 收集器的示意图如下：

![](https://s2.loli.net/2024/12/20/XVIwbtksjyq9EKd.jpg)

```
虽然
```

`ParNew` 使用了多条线程进行垃圾回收

- 单线程环境下它绝对不会比 `Serial` 收集效率更高，因为多线程存在线程交互的开销
- CPU` 核数的增加，`ParNew`的处理效率会比`Serial` 更高效。

### Parallel Scavenge 收集器（新生|复制算法|控制吞吐）

`Parallel Scavenge` 收集器也是一款新生代收集器，它同样是基于标记 - 复制算法实现的，而且它也能够**并行收集**，这么看来，表面上 `Parallel Scavenge` 与 `ParNew` 非常相似，那么它们之间有什么区别呢？

`Parallel Scavenge` 的关注点主要在**达到一个可控制的吞吐量上面**。吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比。也就是

![](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202203021545539.jpeg)

这里给大家举一个吞吐量的例子，如果执行用户代码的时间 + 运行垃圾收集的时间总共耗费了 100 分钟，其中垃圾收集耗费掉了 1 分钟，那么吞吐量就是 99%。停顿时间越短就越适合需要与用户交互或需要保证服务响应质量，良好的响应速度可以提升用户体验，而高吞吐量可以最高效率利用处理器资源。

### Serial Old 收集器（老年|复制算法|单线程）

```
前面介绍了一下
```

`Serial`，我们知道它是一个新生代的垃圾收集，使用了标记 - 复制算法。而这个 `Serial Old` 收集器却是 Serial 的老年版本，它同样也是一个单线程收集器，使用的是**标记 - 整理**算法。

Serial Old 收集器有两种用途：

- 一种是在 `JDK 5` 和之前的版本与 `Parallel Scavenge` 收集器搭配使用，
- 另外一种用法就是作为 `CMS` 收集器的备选，`CMS` 垃圾收集器我们下面说，`Serial Old` 的收集流程如下

![](https://s2.loli.net/2024/12/20/BlE1N9ztDf3TO7M.jpg)

### Parallel Old 收集器（老年|复制算法|多线程）

```
前面我们介绍了
```

`Parallel Scavenge` 收集器，现在来介绍一下 `Parallel Old` 收集器，它是 `Parallel Scavenge` 的老年版本，支持多线程并发收集，基于标记 - 整理算法实现，`JDK 6` 之后出现，吞吐量优先可以考虑 `Parallel Scavenge + Parallel Old` 的搭配

![](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202203021545344.jpeg)

### CMS 收集器(清除算法|四个步骤|JDK9不再推荐默认)

> 三次标记+1次清除
>
> 问题：资源敏感、浮动垃圾、空间碎片

```
```

`CMS`收集器的主要目标是获取**最短的回收停顿时间**，它的全称是【 _**Concurrent Mark Sweep**_】，从这个名字就可以知道，这个收集器是基于标记 - 清除算法实现的，而且支持并发收集，它的运行过程要比上面我们提到的收集器复杂一些，它的工作流程如下：

* 初始标记（`CMS initial mark`）：**_Stop The World_**，初始标记只是标记一下和 `GC Roots` 直接关联到的对象，速度较快；
* 并发标记（`CMS concurrent mark`）: **_Stop The World_**，从 `GC Roots` 的直接关联对象开始遍历整个对象图的过程。这个过程时间比较长但是不需要停顿用户线程，也就是说与垃圾收集线程一起并发运行
* 重新标记（`CMS remark`）：并发标记的过程中，可能会有错标或者漏标的情况，此时就需要在重新标记一下
* 并发清除（`CMS concurrent sweep`）：清理掉标记阶段中判断已经死亡的对象

```
CMS 的收集过程如下
```


![](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202203021545859.jpeg)

`CMS` 是一款非常优秀的垃圾收集器，但是没有任何收集器能够做到完美的程度，`CMS` 也是一样，`CMS` 至少有**三个缺点**：

* `CMS` 对处理器资源非常敏感，在并发阶段，虽然不会造成用户线程停顿，但是却会因为**占用一部分线程**而导致**应用程序变慢**，降低总吞吐量。
* `CMS` 无法处理**浮动垃圾**，有可能出现 **_Concurrent Mode Failure_** 失败进而导致另一次完全 **_Stop The World_** 的 **_Full GC_** 产生。

  > 什么是浮动垃圾呢？
  >
  > ```
  > 由于
  > ```
  >
  > **并发标记和并发清理**阶段，用户线程仍在继续运行，所以程序自然而然就会伴随着新的垃圾不断出现，而且这一部分垃圾出现在**标记结束**之后，`CMS` 无法处理这些垃圾，所以只能等到**下一次垃圾回收**时在进行清理。这一部分垃圾就被称为浮动垃圾。
  >
* `CMS` 最后一个缺点是并发 - 清除的通病，也就是会有大量的**空间碎片**出现，这将会给分配大对象带来困难。

### Garbage First 收集器（回收集）

```
```

`Garbage First` 又被称为 **G1** 收集器，它的出现意味着垃圾收集器走过了一个里程碑，为什么说它是里程碑呢？

```
因为
```

`G1` 这个收集器是一种**面向局部**的垃圾收集器，`HotSpot` 团队开发这个垃圾收集器为了让它**替换掉 CMS 收集器**。

```
所以到后来，
```

**JDK 9** 发布后，☑️**G1** 取代【 **Parallel Scavenge + Parallel Old** 】组合，成为**服务端默认**的垃圾收集器，而 **CMS 则不再推荐使用**。

```
之前的垃圾收集器存在回收区域的局限性，因为之前这些垃圾收集器的目标范围要么是整个新生代、要么是整个老年代，要么是整个
```

`Java` 堆（`Full GC`），而 `G1` 跳出了这个框架，它可以面向堆内存的任何部分来组成**回收集 (Collection Set，CSet)**，衡量垃圾收集的不再是哪个分代，这就是 `G1` 的 _`Mixed GC`_ 模式。

```
```

`G1` 是基于 `Region` 来进行回收的，`Region` 就是**堆内存中任意的布局**，每一块 `Region` 都可以根据需要**扮演** 【`Eden` 空间、`Survivor` 空间或者老年代空间】，收集器能够对不同的 `Region` 角色采用**不同的策略**来进行处理。

```
```

`Region` 中还有一块**特殊的区域**，这块区域就是 _`Humongous`_ 区域，它是专门用来存**储大对象**的。

- 占`Region`容量一半对象：`G1` 认为只要大小超过了 `Region` **容量一半**的对象即可判定为**大对象**。
- 超`Region`容量对象：如果超过了 `Region` 容量的大对象，将会存储在连续的 `Humongous Region` 中，`G1` 大多数行为都会把 `Humongous` `Region` 作为**老年代**来看待。

```
G1 保留了
```

**新生代**（`Eden Suvivor`）和**老年代**的概念，但是新生代和老年代不再是固定的了。它们都是一系列区域的动态集合。

```
G1 收集器的运作过程可以分为以下
```

**四步**：

1. 初始标记：这个步骤也仅仅是标记一下 `GC Roots` 能够**直接关联到的对象**；并修改 `TAMS` 指针的值（每一个 `Region` 都有两个 `RAMS` 指针），使得下一阶段用户并发运行时，能够在可用的 `Region` 中分配对象，这个阶段需要**暂停用户线程**，但是时间很短。这个停顿是借用 `Minor` `GC` 的时候完成的，所以可以忽略不计。
2. 并发标记：从 `GC Root` 开始对堆中对象进行**可达性分析**，递归扫描整个堆中的对象图，找出要回收的对象。当对象图扫描完成后，重新处理 `SATB` 记录下的在并发时有引用的对象；
3. 最终标记：对用户线程做一个**短暂的暂停**，用于处理并发阶段结束后遗留下来的少量 `_SATB_` 记录（一种**原始快照**，用来记录并发标记中某些对象）
4. 筛选回收：负责更新 `Region` 的**统计数据**，对各个 `Region` 的**回收价值**和**成本**进行排序，根据用户所期望的停顿时间来**制定回收计划**，可以自由选择多个 `Region` 构成回收集，然后把决定要回收的那一部分 `Region` 存活对象复制到空的 `Region` 中，再清理掉整个旧 `Region` 的全部空间。这里的操作设计对象的移动，所以必须要**暂停用户线程**，由多条收集器线程**并行收集**

```
从上面这几个步骤可以看出，除了并发标记外，其余三个阶段都需要暂停用户线程，所以，这个 G1 收集器并非追求
```

**低延迟**，官方给出的设计目标是**在延迟可控的情况下尽可能的提高吞吐量**，担任全功能收集器的重任。

下面是 G1 回收的示意图

![](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202203021545455.jpeg)

`G1` 收集器同样也有缺点和问题：

* 第一个问题就是 `Region` 中存在**跨代**引用的问题，我们之前知道可以用记忆集来解决跨代引用问题，不过 `Region` 中的跨代引用要复杂很多；
* 第二个问题就是如何保证**收集线程与用户线程互不干扰**的运行？`CMS` 使用的是增量更新算法，`G1` 使用的是原始快照（`SATB`），`G1` 为 `Region` 分配了两块 `TAMS` 指针，把 `Region` 中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须在这两个指针位置以上。如果内存回收速度赶不上内存分配速度，`G1` 收集器也要冻结用户线程执行，导致 `Full` `GC` 而产生长时间的 `STW`。
* 第三个问题是**无法建立可预测的停顿模型。**
