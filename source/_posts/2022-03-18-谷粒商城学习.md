---
title: 谷粒商城学习
tags:
  - JAVA
  - 项目
categories: 项目
summary: 谷粒商城项目搭建、开发部署上线运维全流程
abbrlink: 57306
date: 2022-05-18 15:34:15
---
<meta name="referrer" content="no-referrer"/>

![题图](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204072146144.png)

<!--more-->

# docker 安装
 
## docker 安装MySQL

1. 下载镜像

   ```shell
   docker pull mysql:5.7
   ```

2. 创建实例

   ```sh
   docker run -p 3307:3306 --name mysql \
   -v /mydata/mysql/log:/var/log/mysql \
   -v /mydata/mysql/data:/var/lib/mysql \
   -v /mydata/mysql/conf:/etc/mysql \
   -e MYSQL_ROOT_PASSWORD=root \
   -d mysql:5.7
   ```

   参数说明：

   - -p 3306:3306：-p 主机端口:容器端口，将容器的3306端口映射到主机的3306端口
   - -v /mydata/mysql/conf:/etc/mysql：将配置文件夹挂载到主机
   - -v /mydata/mysql/log:/var/log/mysql：将日志文件夹挂载到主机
   - -v /mydata/mysql/data:/var/lib/mysql：将配置文件夹挂载到主机
   - -e MYSQL_ROOT_PASSWORD=root：初始化root用户密码
   - -d mysql:5.7：表示后台运行(-d) 镜像mysql:5.7   -->查看镜像docekr images

3. 进去docker 容器

   ``` sh
   root@af26dd647c9a:/# docker exec -it mysql /bin/bash
   root@af26dd647c9a:/# whereis mysql
   mysql: /usr/bin/mysql /usr/lib/mysql /etc/mysql /usr/share/mysql
   ```

4. mysql配置 my.cnf

   ```sh
   [root@lingzx conf]# vi /mydata/mysql/conf/my.cnf
   ```

   ```sh
   [client]
   default-character-set=utf8
   
   [mysql]
   default-character-set=utf8
   
   [mysqld]
   init_connect='SET collation_connection=utf8_unicode_ci'
   init_connect='SET NAMES utf8'
   character-set-server=utf8
   collation-server=utf8_unicode_ci
   skip-character-set-client-handshake
   skip-name-resolve
   lower_case_table_names=1
   ```

5. 查看docker中MySQL的配置

   ```sh
   cd /etc/mysql
   cat my.cnf
   ```

6. 开机自启

   ```sh
   docker update mysql --restart=always
   ```

   

## docker 安装Redis

1. 下载redis 镜像

   ``` sh 
   docker pull redis
   ```

2. 创建实例并启动

   ```sh
   # 由于 redis容器 /etc/redis目录下没有 redis.conf ，所以需要我们预先在主机上创建一个 redis.conf
   mkdir -p /mydata/redis/conf
   touch /mydata/redis/conf/redis.conf
   
   docker run -p 6379:6379 --name redis \
   -v /mydata/redis/data:/data \
   -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \
   -d redis redis-server /etc/redis/redis.conf
   
   # 连接 docker中的 redis的控制台
   docker exec -it redis redis-cli
   ```

3. 配置持久化

   > 当前版本的redis默认配置了【文件追加写持久化】aof

   ```sh
   vi /mydata/redis/redis.conf
   
   appendonly yes
   
   docker restart redis
   ```

4. 开机自启

   ```sh
   docker update redis --restart=always
   ```

   

# 统一环境

## Maven 3.6.1

> 链接: https://pan.baidu.com/s/1Jd5EAXADSEFop2QT8sxzBA 提取码: 38iw 复制这段内容后打开百度网盘手机App，操作更方便哦

配置阿里云镜像

```xml
<mirrors>
	<mirror>
      <id>nexus-aliyun</id>
      <mirrorOf>central</mirrorOf>
      <name>Nexus aliyun</name>
      <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
    </mirror>
</mirrors> 
```

配置 JDK 1.8 编译环境

```xml
<profiles>
  <profile>
    <id>jdk-1.8</id>
    <activation>
      <activeByDefault>true</activeByDefault>
      <jdk>1.8</jdk>
    </activation>
    <properties>
      <maven.compile.source>1.8</maven.compile.source>
      <maven.compile.target>1.8</maven.compile.target>
      <maven.compile.compilerVersion>1.8</maven.compile.compilerVersion>
    </properties>
  </profile>
</profiles>
```

配置本地仓库

```xml
<localRepository>D:\Program Files\Maven\LocalWareHouse</localRepository>
```

## idea 安装插件

- lombok
- MybatisX

## Vscode 安装配置

- Auto Close Tag
- Auto Rename Tag
- Chinese (Simplified)
- ESLint
- HTML CSS Support
- HTML Snippets
- JavaScript（ES6）
- Live Server
- open in browser
- Vetur

## 安装配置 git

1. 下载 git：https://git-scm.com

2. 配置 git ，进入git bash

   ```sh
   # 配置用户名
   git config --global user.name 'username'
   # 配置邮箱
   git config --global user.email 'username@email.com'
   ```

3. 配置 shh 免密登录，进入git bash

   ```sh
   ssh-keygen -t rsa -C 'xx@xxx.com'
   ```

    三次回车，查找 id_rsa 和 id_rsa.pub

4. 登录 gitee，在设置里面找到 SSH KEY 将 .pub 文件的内容粘贴进去

   ```sh
   # 查看是否成功
   ssh -T git@gitee.com 
   ```

# 创建项目

1. 商品服务、仓储服务、订单服务、优惠券服务、用户服务

   共用：

   1. web 、openfeign
   2. 每个服务，包名 **com.atguigu.gulimall**.xxx(product/order/ware/coupon/member)
   3. 模块名：gulimall-coupon

2. 添加pom文件

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
       <modelVersion>4.0.0</modelVersion>
       <groupId>com.atguigu.gulimall</groupId>
       <artifactId>gulimall</artifactId>
       <version>0.0.1-SNAPSHOT</version>
       <name>gulimall</name>
       <description>聚合服务</description>
       <packaging>pom</packaging>
       <modules>
           <module>gulimall-coupon</module>
           <module>gulimall-member</module>
           <module>gulimall-order</module>
           <module>gulimall-product</module>
           <module>gulimall-ware</module>
       </modules>
   </project>
   ```

3. 设置忽略提交内容 .gitgnore

   ```sh
   **/mvnw
   **/mvnw.cmd
   
   **/.mvn
   **/target/
   
   .idea
   **/.gitignore
   ```

   ![image-20220323234601504](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202203232346905.png) 

4. 提交并推送到仓库

## 数据库设计 PowerDesigner

1. ![image-20220324004223247](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202203240042296.png) 

7. ![image-20220324004234654](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202203240042710.png) 

2. 每个微服务创建自己的数据库

## 人人开源快速开发

### 后端管理 renren-fast

1. 克隆项目

   > git clone git@gitee.com:renrenio/renren-fast.git
   
2. 将renren-fast 放在gulimall项目pom中 module

   > <module>renren-fast</module>

3. 新增数据库 gulimall_admin

4. 修改pom

   1. 关联gulimall

      ```xml
      <parent>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-parent</artifactId>
          <version>2.3.7.RELEASE</version>
          <relativePath/>
      </parent>
      ```

   2. 解决@NotBlank 和 @Email 报错

      ```xml
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-validation</artifactId>
      </dependency>
      ```

5. 修改数据库配置，连接到 gulimall_admin 的配置信息

### 前端管理 renren-fast-vue

1. 克隆项目

   > git clone git@gitee.com:renrenio/renren-fast-vue.git

2. 将项目拖到VSCode中

3. 统一配置

   1. nodeJs，

      > node 版本 14 可以解决所有的报错
      >
      > 关注 node.js 的 npm 功能
      >
      > NPM 是NodeJS的包管理工具，JS-NPM，Java-Maven

      - 官网下载安装，node -v 检查版本

      - 配置npm 淘宝镜像

        ```sh
        npm config set registry http://registry.npm.taobao.org/
        ```

      - 下载依赖包

        ```sh
        npm install
        ```

      - 报错处理

        ```sh
        npm install --save  -g core-js@^3
        ```

      - node-sass报错 是由于版本的问题，在package.json中可以解决

   2. Vue

### 代码生成 renren-generator

 1. 克隆项目

    > git clone git@gitee.com:renrenio/renren-generator.git

	2. 将项目拖到 idea 中

	3. 修改配置（以 product 模块为例子）

    - 修改 generator.properties

      ```properties
      #代码生成器，配置信息
      mainPath=com.atguigu
      #包名
      package=com.atguigu.gulimall
      moduleName=product
      #作者
      author=Mr.Ling
      #Email
      email=lingzhexi@163.com
      #表前缀(类名不会包含表前缀)
      tablePrefix=pms_
      ```

    - 修改 Controller.java.vm 模板

      ```java
      注释 @RequeiresPermissions 注解
      //@RequiresPermissions("${moduleName}:${pathName}:list")
      ```

    - 修改数据库配置( pms )

      ```yml
      spring:
        datasource:
          type: com.alibaba.druid.pool.DruidDataSource
          #MySQL配置
          driverClassName: com.mysql.cj.jdbc.Driver
          url: jdbc:mysql://localhost:13306/gulimall_pms?useUnicode=true&characterEncoding=UTF-8&useSSL=false&serverTimezone=Asia/Shanghai
          username: root
          password: root
      ```

	4. 启动项目，生成代码

    - 点击生成代码

      ![image-20220407215910844](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204072159051.png)

    - 将代码放到 product 模块中

### 新增 gulimall-common

- 通用的依赖模块 ，product 模块引用该模块

  ```xml
  <dependency>
      <groupId>com.baomidou</groupId>
      <artifactId>mybatis-plus-boot-starter</artifactId>
      <version>3.3.1</version>
  </dependency>
  <dependency>
      <groupId>org.projectlombok</groupId>
      <artifactId>lombok</artifactId>
      <version>1.18.22</version>
  </dependency>
  <dependency>
      <groupId>commons-lang</groupId>
      <artifactId>commons-lang</artifactId>
      <version>2.6</version>
  </dependency>
  <dependency>
      <groupId>org.apache.httpcomponents</groupId>
      <artifactId>httpcore</artifactId>
      <version>4.4.14</version>
  </dependency>
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-validation</artifactId>
      <version>2.3.7.RELEASE</version>
  </dependency>
  ```

## 整合Mybatis-pus

1. 导入依赖

   ```xml
   <dependency>
       <groupId>com.baomidou</groupId>
       <artifactId>mybatis-plus-boot-starter</artifactId>
       <version>3.3.1</version>
   </dependency>
   ```

2. 配置

   1. 配置数据源

      1. 导入MySql 驱动

         推荐使用 8 版本的Mysql connector![image-20220410002401508](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204100039304.png)

         ```xml
         <!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
         <dependency>
             <groupId>mysql</groupId>
             <artifactId>mysql-connector-java</artifactId>
             <version>8.0.28</version>
         </dependency>
         ```

      2. 整合 application.yml

         ```yml
         server:
             port: 8080
         spring:
             application:
                 name: gulimall-product
             datasource:
                 username: root
                 password: root
                 url: jdbc:mysql://localhost:13306/gulimall_pms
                 driver-class-name: com.mysql.cj.jdbc.Driver
         
         ```

   2. 配置 mybaits-plus

      1. 主启动配置 @MapperScan("com.atguigu.gulimall.product.dao")

         ![image-20220410004352680](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204100043736.png) 

      2. 告诉 MyBatis-Plus ， sql 映射文件位置

         默认位置类路径下的 classpath*:/mapper/**/*.xml

         ![image-20220410004908204](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204100049256.png) 

         ```yml
         mybatis-plus:
         	mapper-locations: classpath:/mapper/**/*.xml
         ```

      3. 设置主键自增配置
      
         ```yml
         # 填写 id 自动联想出来
         mybatis-plus: 
          global-config:
                 db-config:
                     id-type: auto
         ```
   
   ​	**各模块最终需要依赖到 gulimall-common** 

# 整合微服务

 ![image-20220411213056325](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204112131562.png)

## 搭配方案：

- SpringCloud Alibaba - Nacos : 注册中心 （服务发现/注册）
- SpringCloud Alibaba - Nacos : 配置中心 （动态配置管理）
- SpringCloud - Ribbon :  负载均衡
- SpringCloud - Feign : 声明式 HTTP 客户端 （调用远程服务）
- SpringCloud Alibaba - Sentinel : 服务容错 （限流、降级、熔断）
- SpringCloud - Gateway : API 网关 （webflux 编程模式）
- SpringCloud - Sleuth : 调用链监控
- SpringCloud Alibaba - Seata : 原 Fescar 即分布式事务解决方案 	

阿里巴巴中文文档：[SpringCloud Alibab 中文文档](https://github.com/alibaba/spring-cloud-alibaba/blob/2021.x/README-zh.md)

## 版本选择：

![image-20220411215026972](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204112150099.png)  

SpringCloud - SpringBoot 版本对比（[SpringCloud 官网](https://spring.io/projects/spring-cloud)）

![image-20220411215056217](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204112150336.png) 

SpringCloud Alibaba - SpringBoot 版本对比 （ [SpringCloud Alibaba Github](https://github.com/alibaba/spring-cloud-alibaba/blob/2021.x/README-zh.md)）

![image-20220411220224816](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204112202930.png) 

将 SpringCloud Alibaba 依赖 加入 gulimall-common 中  

```xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-alibaba-dependencies</artifactId>
            <version>2.1.0.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

 

## 注册中心

[nacos 注册中心](https://github.com/alibaba/spring-cloud-alibaba/blob/2021.x/spring-cloud-alibaba-docs/src/main/asciidoc-zh/nacos-discovery.adoc)

### 服务注册/发现 Nacos Discovery

1. 引入依赖，加入gulimall-common

   ```xml
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
   </dependency>
   ```

   优惠卷模块引入 nacos discovery 依赖

    ![image-20220411222218474](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204112222593.png) 

2. 配置Nacos Server 地址

   ```yml
   spring:
   	cloud:
   		nacos:
   			discovery:
   				server-addr: 127.0.0.1:8848
   ```

3. 使用 @EnableDiscoveryClient 注解开启服务注册和发现
   ![image-20220411222803578](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204112228697.png) 

4. 查看注册的服务

   >  登录后台 127.0.0.1:8848/nacos 
   >
   > 用户信息：nacos/nacos

   ![image-20220411223200216](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204112232366.png) 

## 远程调用

1. 引入 open-feign

2. 编写一个接口，告诉SpringCloud 需要调用远程接口

   - 新建一个feign 包

   - 写一个接口

     ```java
     @FeignClient("gulimall-coupon") //表示 nacos 注册中心中的找到服务名为 gulimall-coupon 的服务
     public interface CouponFeignService {
     
         @RequestMapping("/coupon/coupon/member/coupon") // 找到优惠券服务中的该接口
         public R memberCoupons();
     }
     ```

3. 开启远程调用功能 

   在主启动中添加 @EnableFeignClients(basePackages="xx") xx表示指定feign的接口包

   ```java
   @EnableFeignClients(basePackages = "com.atguigu.gulimall.member.feign") //此时的basePackages 可以省略
   @EnableDiscoveryClient
   @MapperScan("com.atguigu.gulimall.member.dao")
   @SpringBootApplication
   public class GulimallMemberApplication {
   
       public static void main(String[] args) {
           SpringApplication.run(GulimallMemberApplication.class, args);
       }
   
   } 
   ```

4. 示例

   - 添加远程接口

     ```java
     @RestController
     @RequestMapping("coupon/coupon")
     public class CouponController {
         @Autowired
         private CouponService couponService;
     
         /**
          * 会员优惠券
          */
         @RequestMapping("/member/coupon")
         public R memberCoupons() {
             CouponEntity couponEntity = new CouponEntity();
             couponEntity.setCouponName("满100减10");
             return R.ok().put("coupons", Arrays.asList(couponEntity));
         }
     }
     ```

   - 添加调用接口

     ```java
     @RestController
     @RequestMapping("member/member")
     public class MemberController {
         @Autowired
         private MemberService memberService;
     
         @Autowired
         CouponFeignService couponFeignService;
     
         @RequestMapping("/coupons")
         public R test() {
             MemberEntity memberEntity = new MemberEntity();
             memberEntity.setNickname("张三");
             R r = couponFeignService.memberCoupons();
             return R.ok().put("member", memberEntity).put("coupons", r.get("coupons"));
         }
     }
     ```

   - 请求接口 localhost:8000/member/member/coupons

     

## 配置中心：动态管理配置

[nacos 配置中心文档](https://github.com/alibaba/spring-cloud-alibaba/blob/2021.x/spring-cloud-alibaba-examples/nacos-example/nacos-config-example/readme-zh.md)

1. 引入 Nacos Config  Starter

   ```xml
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
   </dependency>
   ```

2. 创建 bootstrap.yml，配置 Nacos 元数据

   ```yml
   spring:
   	application:
   		name: gulimall-coupon
   	cloud:
   		nacos:
   			config:
   				server-addr: 127.0.0.1:8848
   ```

3. 配置中心 添加 数据集（Data Id） gulimall-coupon.properties ，默认规则，应用名.properties
   ![image-20220412213509978](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204122135151.png) 

   ![image-20220412214528762](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204122145876.png) 

4. 动态获取配置
    @RefreshScope ：动态获取并刷新配置

    @Value("${配置项的名}") ：获取到配置

   如果配置中心和当前应用都配置相同的项，优先使用配置中心的配置

   ```java
   @RefreshScope //动态刷新
   @RestController
   @RequestMapping("coupon/coupon")
   public class CouponController {
       @Autowired
       private CouponService couponService;
   
       @Value("${coupon.user.name}")
       private String name;
       @Value("${coupon.user.age}")
       private Integer age;
       @GetMapping("/test")
       public R test() {
           return R.ok().put("name",name).put("age",age);
       }
   }
   ```

5. 核心概念

   ![image-20220412220641506](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204122206664.png)

   - 命名空间：配置隔离 

     默认 public ：默认新增的所有都在该空间下

     1. 开发、测试、生产 ：利用命名空间来做环境隔离

        注意：在bootstrap.yml 配置中，需要使用那个命名空间下的配置

        ```yml
        spring.cloud.nacos.config.namespace=cc749289-b027-486f-bb6a-3febcabecbdb
        ```

        ![image-20220412220837375](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204122217795.png) 

     2. 每个服务应用之间相互隔离，管理微服务自己的配置
        ![image-20220412223231969](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204122232120.png)

   - 配置集：所有配置的集合

   - 配置集ID：类似文件名 （Data ID： 文件名）

   - 配置分组：默认所有的配置集都属于：DEFAULT_GROUP；

     - 组名：1111 、618 、1212

     - ![image-20220412224056530](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204122240653.png) 

     - 添加分组配置

       ```properties
       spring.cloud.nacos.config.group=1111
       ```

   - 每个微服务创建自己的命名空间，使用配置分组区分环境，dev、test、prod 环境

     ![ ](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204122247441.png)	 

6. 同时加载多个配置集

   - 微服务任何配置信息，任何配置文件都可以放在配置中心中
     ![image-20220412233717240](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204122337360.png)

   - 只需要在 bootstrap.yml 说明 加载配置中心中的那些配置文件即可

     ```yml
     spring:
       appliation:
         name: gulimall-coupon
       cloud:
         nacos:
           config:
             server-addr: 127.0.0.1:8848
             namespace: d6545d08-333c-4806-bf43-6acc99acecc6
             # 数据库配置
             ext-config[0].data-id: datasource.yml
             ext-config[0].group: dev
             ext-config[0].refresh: true
             # mybatis 配置
             ext-config[1].data-id: mybatis.yml
             ext-config[1].group: dev
             ext-config[1].refresh: true
             # 其他配置
             ext-config[2].data-id: other.yml
             ext-config[2].group: dev
             ext-config[2].refresh: true
     ```

     ![image-20220412233550198](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204122335376.png)

   - @Value，@ConfigurationProperties  以前SpringBoot 任何方法从配置文件中获取值，都能使用

   - 配置中心有优先使用配置

## 网关 GateWay

 [SpringGateway 官方文档](https://spring.io/projects/spring-cloud-gateway)	

​	网关作为流量的入口，常用功能包括 **路由转发、权限校验、限流控制**等，而springcloud gateway
作为SpringCloud官方推出的第二代网关框架，取代了Zuul网关。

### 特征

Spring Cloud Gateway 的特点：

- 基于Spring Framework 5、Project Reactor和Spring Boot 2.0构建
- 能够匹配任何请求属性上的路由。
- 谓词和筛选器特定于路由。
- 断路器集成。
- 春云发现客户端集成
- 易于编写谓词和筛选器
- 请求速率限制
- 路径重写

![image-20220415142458247](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204151424445.png) 

![image-20220415142513181](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204151425268.png) 

![image-20220415143618115](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204151436336.png)

### 概念

- Route（路由）：网关的基本构建基块。它由 **ID、目标 URI**、**断言集合**和**过滤器集合**定义。如果**断言集合为 true**，则匹配路由

- Predicate（断言）：这是一个 [Java 8 函数断言](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html)。输入类型是[Spring Framework `ServerWebExchange`](https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/server/ServerWebExchange.html)。这使您可以匹配 HTTP 请求中的任何内容，例如标头或参数。

- Filter（过滤器）：这些是使用特定工厂构建的[`网关过滤器`](https://github.com/spring-cloud/spring-cloud-gateway/tree/2.2.x/spring-cloud-gateway-server/src/main/java/org/springframework/cloud/gateway/filter/GatewayFilter.java)实例。在这里，您可以修改发送下游请求之前或之后的请求和响应

### 工作原理：

![Spring Cloud Gateway Diagram](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204151448583.png) 

总结：当请求到达网关，网关利用断言，判断此次请求是不是符合某个路由规则，如果符合了就按照路由规则，路由到指定的地方。当要去指定的地方就要经过一系列的filter进行过滤

### 配置示例 

[路由断言工厂](https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#gateway-request-predicates-factories)

#### After Route Predicate Factory：后路由断言工厂

路由断言工厂采用一个参数 a（这是一个 java）。此断言匹配在指定日期时间之后发生的请求。以下示例配置路由之后断言：

application.yml

```yml
spring:
  cloud:
    gateway:
      routes:
      - id: after_route
        uri: https://example.org
        # 断言（条件）：判断请求是在指定的时间后（After)发生的
        predicates:
        - After=2017-01-20T17:42:47.789-07:00[America/Denver]
```

[网关过滤器工厂](https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#gatewayfilter-factories)

#### AddRequestHeader GatewayFilter Factory：添加请求头网关过滤器工厂

application.yml

```yaml
spring:
  cloud:
    gateway:
      routes:
      - id: add_request_header_route
      	# 请求没有断言，任何请求直接跳转到这个链接
        uri: https://example.org
        filters:
        - AddRequestHeader=X-Request-red, blue
```

此列表将标头添加到所有匹配请求的下游请求头中`X-Request-red:blue`

AddRequestHeader`了解用于匹配路径或主机的 URI 变量。URI 变量可以在值中使用，并在运行时展开。下面的示例配置使用变量的 一个：`AddRequestHeader``GatewayFilter

[全局过滤器工厂](https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#global-filters)

### 创建网关

1. 创建新 module gulimall-gateway

2. 添加 gateway 依赖，~~添加 gulimall-common 依赖~~，添加nacos 配置中心和服务中心依赖

   ```xml
    <properties>
           <java.version>1.8</java.version>
           <spring-boot.version>2.1.8.RELEASE</spring-boot.version>
           <spring-cloud.alibaba.version>2.1.0.RELEASE</spring-cloud.alibaba.version>
           <spring-cloud.version>Greenwich.SR3</spring-cloud.version>
       </properties>
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-gateway</artifactId>
   </dependency>
    <!--nacos 服务注册/发现-->
           <dependency>
               <groupId>com.alibaba.cloud</groupId>
               <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
               <version>${spring-cloud.alibaba.version}</version>
           </dependency>
           <!--naocs 配置中心-->
           <dependency>
               <groupId>com.alibaba.cloud</groupId>
               <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
               <version>${spring-cloud.alibaba.version}</version>
           </dependency>
   </dependency>
   ```

3. 统一 Spring boot、Spring Cloud 版本

   - boot：2.1.8.RELEASE
   - cloud：Greenwich.SR3 

4. 项目新建 bootstrap.yml 填写 nacos 配置中心 

   ```yaml
   spring:
       application:
           name: gulimall-gateway
       cloud:
           nacos:
               config:
                   server-addr: 127.0.0.1:8848
                   namespace: 4b9add0d-df21-4fc6-ad9c-35936b491b10s	
   ```

5. 配置中心 新建网关配置命名空间

   - 新建命名空间 gateway

   - 新建配置文件 gulimall-gateway.propertie 

     ```properties
     spring.application.name=gulimall-gateway
     ```

   - ![image-20220421225143278](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204212251449.png)

6. application.properties 配置服务中心

   ```properties
   server.port=88
   spring.application.name=gulimall-gateway
   spring.cloud.nacos.discovery.server-addr=127.0.0.1
   ```

7. 启动成功 
   ![image-20220421230109723](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204212301809.png)

8. 配置路由断言

   新建一个application.yml

   ![image-20220421230443693](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202204212304803.png)

   ```yml
   spring:
   	cloud:
   		gateway:
   			routes:
                   -id: bing_route
                   uri: https://www.bing.com
                   predicates:
   					# query 表示请求参数 ，参数 url ，参数值正则 baidu
                   	-Query=url,bing
                    -id: bing_route
                   uri: https://www.bing.com
                   predicates:
   					# query 表示请求参数 ，参数 url ，参数值正则 baidu
                   	-Query=url,bing
   			
   ```

   请求路径：

   - ~~百度地址：http://127.0.0.1:88/hello?url=baidu~~~~，无法跳转到百度~~

   - 必应地址：http://127.0.0.1:88/hello?url=bing

   - QQ地址：http://127.0.0.1:88/hello?url=qq

# 前端基础

## 前后端对比

![在这里插入图片描述](https://gcore.jsdelivr.net/gh/lingzhexi/blogImage/img/2022/03/202205131014934.png) 

## ES6

> ECMAScript 6.0（以下简称 ES6，ECMAScript是一种由Ecma国际通过ECMA-262标准化的脚本）， 是JavaScript语言的下一代标准，2015年6月正式发布，从ES6开始的版本号采用年号，如ES2015，就是ES6。ES2016就是ES7。 ECMAScript是规范，JS的规范的具体实现。

### let & const

- 作用域：var在{}之外也起作用 let在{}之外不起作用 
- 声明次数：var 多次声明同一变量不会报错，let多次声明会报错，只能声明一次。
- 变量提升：var 会变量提升（打印和定义可以顺序反）；let 不存在变量提升（顺序不能反） 
- const 声明之后不允许改变

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    

    <script>
       // var 声明的变量往往会越域
       // let 声明的变量有严格局部作用域
//         {
//             var a = 1;
//             let b = 2;
//         }
//         console.log(a);  // 1
//         console.log(b);  // ReferenceError: b is not defined

    // var 可以声明多次
            // let 只能声明一次
//         var m = 1
//         var m = 2
//         let n = 3
//       let n = 4
//         console.log(m)  // 2
//         console.log(n)  // Identifier 'n' has already been declared

        // var 会变量提升
        // let 不存在变量提升
//         console.log(x);  // undefined
//         var x = 10;
//         console.log(y);   //ReferenceError: y is not defined
//         let y = 20;

        // const
        // 1. const声明之后不允许改变
        // 2. 一但声明必须初始化，否则会报错
        const a = 1;
        a = 3; //Uncaught TypeError: Assignment to constant variable.
    
    </script>

</body>
</html>
```

### 解构表达式

- 数组解构：支持 let arr = [1,2,3]; let [a,b,c] = arr
- 冒号改名：const { name: abc, age, language } = person
- 字符串函数：支持一个字符串为多行 占位符功能 ${}

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

    <script>
        //数组解构
        // let arr = [1,2,3];
        // // let a = arr[0];
        // // let b = arr[1];
        // // let c = arr[2];

        // let [a,b,c] = arr;
        // console.log(a,b,c)

        const person = {
            name: "jack",
            age: 21,
            language: ['java', 'js', 'css']
        }
        //         const name = person.name;
        //         const age = person.age;
        //         const language = person.language;

        //对象解构
        const { name: abc, age, language } = person;
        console.log(abc, age, language)

        // 字符串扩展
        let str = "hello.vue";
        console.log(str.startsWith("hello"));//true
        console.log(str.endsWith(".vue"));//true
        console.log(str.includes("e"));//true
        console.log(str.includes("hello"));//true

        //字符串模板
        let ss = `<div>
                    <span>hello world<span>
                </div>`;
        console.log(ss);

        // 字符串插入变量和表达式。变量名写在 ${} 中，${} 中可以放入 JavaScript 表达式。

        function fun() {
            return "这是一个函数"
        }

        let info = `我是${abc}，今年${age + 10}了, 我想说： ${fun()}`;
        console.log(info);

    </script>
</body>
</html>
```

### 函数优化

- 函数默认值： b = b || 1; 现在可以直接写了function add2(a, b = 1) 
- 不定参数：function fun(...values) {
- 支持箭头函数（lambda表达式），还支持使用{}结构传入对象的成员

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

    <script>
        //在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法：
        function add(a, b) {
            // 判断b是否为空，为空就给默认值1
            b = b || 1;
            return a + b;
        }
        // 传一个参数
        console.log(add(10));


        //现在可以这么写：直接给参数写上默认值，没传就会自动使用默认值
        function add2(a, b = 1) {
            return a + b;
        }
        console.log(add2(20));


        //不定参数
        function fun(...values) {
            console.log(values.length)
        }
        fun(1, 2)      //2
        fun(1, 2, 3, 4)  //4

        //箭头函数
        //以前声明一个方法
        // var print = function (obj) {
        //     console.log(obj);
        // }
        var print = obj => console.log(obj);
        print("hello");

        var sum = function (a, b) {
            c = a + b;
            return a + c;
        }

        var sum2 = (a, b) => a + b;
        console.log(sum2(11, 12));

        var sum3 = (a, b) => {
            c = a + b;
            return a + c;
        }
        console.log(sum3(10, 20))


        const person = {
            name: "jack",
            age: 21,
            language: ['java', 'js', 'css']
        }

        function hello(person) {
            console.log("hello," + person.name)
        }

        //箭头函数+解构
        var hello2 = ({name}) => console.log("hello," +name);
        hello2(person);

    </script>
</body>
</html>
```

### 对象优化

- map：获取map的键值对等Object.keys()、values、entries
- 对象合并：Object.assign(target,source1,source2)
- 声明简写：const person2 = { age, name }
- 对象拷贝：let someone = { …p1 }

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        const person = {
            name: "jack",
            age: 21,
            language: ['java', 'js', 'css']
        }

        console.log(Object.keys(person));//["name", "age", "language"]
        console.log(Object.values(person));//["jack", 21, Array(3)]
        console.log(Object.entries(person));//[Array(2), Array(2), Array(2)]

        const target = { a: 1 };
        const source1 = { b: 2 };
        const source2 = { c: 3 };

        //{a:1,b:2,c:3}
        Object.assign(target, source1, source2);

        console.log(target);//["name", "age", "language"]

        // 声明对象简写
        const age = 23
        const name = "张三"
        const person1 = { age: age, name: name }

        const person2 = { age, name }//声明对象简写
        console.log(person2);

        // 对象的函数属性简写
        let person3 = {
            name: "jack",
            // 以前：
            eat: function (food) {
                console.log(this.name + "在吃" + food);
            },
            //箭头函数this不能使用，对象.属性
            eat2: food => console.log(person3.name + "在吃" + food),
            eat3(food) {
                console.log(this.name + "在吃" + food);
            }
        }

        person3.eat("香蕉");
        person3.eat2("苹果")
        person3.eat3("橘子");

        // 对象拓展运算符

        //  拷贝对象（深拷贝）
        let p1 = { name: "Amy", age: 15 }
        let someone = { ...p1 }
        console.log(someone)  //{name: "Amy", age: 15}

        //  合并对象
        let age1 = { age: 15 }
        let name1 = { name: "Amy" }
        let p2 = {name:"zhangsan"}
        p2 = { ...age1, ...name1 } 
        console.log(p2)
    </script>
</body>

</html>
```

### map和reduce

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
    <script>
        //数组中新增了map和reduce方法。
        //map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。
         let arr = ['1', '20', '-5', '3'];
         
        //  arr = arr.map((item)=>{
        //     return item*2
        //  });
         arr = arr.map(item=> item*2);

        

         console.log(arr);
        //reduce() 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，
        //[2, 40, -10, 6]
        //arr.reduce(callback,[initialValue])
        /**
     1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））
    2、currentValue （数组中当前被处理的元素）
    3、index （当前元素在数组中的索引）
    4、array （调用 reduce 的数组）*/
        let result = arr.reduce((a,b)=>{
            console.log("上一次处理后："+a);
            console.log("当前正在处理："+b);
            return a + b;
        },100);
        console.log(result)

    
    </script>
</body>
</html>
```

### promise

- 封装：赋值给 let p 在Ajax中成功使用 resolve(data)，交给then处理， 失败使用reject(err)，交给catch处理p.then().catch()

```json
//corse_score_10.json 得分
{
    "id": 100,
    "score": 90
}

//user.json 用户
{
    "id": 1,
    "name": "zhangsan",
    "password": "123456"
}


//user_corse_1.json 课程
{
    "id": 10,
    "name": "chinese"
}
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
</head>
<body>
    <script>
        //1、查出当前用户信息
        //2、按照当前用户的id查出他的课程
        //3、按照当前课程id查出分数
        // $.ajax({
        //     url: "mock/user.json",
        //     success(data) {
        //         console.log("查询用户：", data);
        //         $.ajax({
        //             url: `mock/user_corse_${data.id}.json`,
        //             success(data) {
        //                 console.log("查询到课程：", data);
        //                 $.ajax({
        //                     url: `mock/corse_score_${data.id}.json`,
        //                     success(data) {
        //                         console.log("查询到分数：", data);
        //                     },
        //                     error(error) {
        //                         console.log("出现异常了：" + error);
        //                     }
        //                 });
        //             },
        //             error(error) {
        //                 console.log("出现异常了：" + error);
        //             }
        //         });
        //     },
        //     error(error) {
        //         console.log("出现异常了：" + error);
        //     }
        // });


        //1、Promise可以封装异步操作
        // let p = new Promise((resolve, reject) => { //传入成功解析，失败拒绝
        //     //1、异步操作
        //     $.ajax({
        //         url: "mock/user.json",
        //         success: function (data) {
        //             console.log("查询用户成功:", data)
        //             resolve(data);
        //         },
        //         error: function (err) {
        //             reject(err);
        //         }
        //     });
        // });

        // p.then((obj) => { //成功以后做什么
        //     return new Promise((resolve, reject) => {
        //         $.ajax({
        //             url: `mock/user_corse_${obj.id}.json`,
        //             success: function (data) {
        //                 console.log("查询用户课程成功:", data)
        //                 resolve(data);
        //             },
        //             error: function (err) {
        //                 reject(err)
        //             }
        //         });
        //     })
        // }).then((data) => { //成功以后干什么
        //     console.log("上一步的结果", data)
        //     $.ajax({
        //         url: `mock/corse_score_${data.id}.json`,
        //         success: function (data) {
        //             console.log("查询课程得分成功:", data)
        //         },
        //         error: function (err) {
        //         }
        //     });
        // })

        function get(url, data) { //自己定义一个方法整合一下
            return new Promise((resolve, reject) => {
                $.ajax({
                    url: url,
                    data: data,
                    success: function (data) {
                        resolve(data);
                    },
                    error: function (err) {
                        reject(err)
                    }
                })
            });
        }

        get("mock/user.json")
            .then((data) => {
                console.log("用户查询成功~~~:", data)
                return get(`mock/user_corse_${data.id}.json`);
            })
            .then((data) => {
                console.log("课程查询成功~~~:", data)
                return get(`mock/corse_score_${data.id}.json`);
            })
            .then((data)=>{
                console.log("课程成绩查询成功~~~:", data)
            })
            .catch((err)=>{ //失败的话catch
                console.log("出现异常",err)
            });

    </script>
</body>

</html>
```

### 模块化

- 代码拆分：类似Java导包，导模块。 
- 命令：export 和 import 
  - export 用于规定模块的对外接口 
  - import 用于导入其他模块提供的功能

```js
user.js
var name = "jack"
var age = 21
function add(a,b){
    return a + b;
}

export {name,age,add}

hello.js
// export const util = {
//     sum(a, b) {
//         return a + b;
//     }
// }

export default {
    sum(a, b) {
        return a + b;
    }
}
// export {util}

//`export`不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。


main.js
import abc from "./hello.js"
import {name,add} from "./user.js"

abc.sum(1,2);
console.log(name);
add(1,3);
```

## Vue

### MVVM思想

- M：model 包括数据和一些基本操作 

- V：view 视图，页面渲染结果 
- VM：View-model，模型与视图间的双向操作（无需开发人员干涉） 视图和数据通过VM绑定起来，model里有变化会自动地通过Directives填写到视view中， 视图表单中添加了内容也会自动地通过DOM Listeners保存到模型中。

### 案例	

```sh
npm init -y
//教学的版本是Vue2，目前版本是Vue3
npm i vue@2 
```

```html
在VSCode中安装vue 2 snippets语法提示插件，在谷歌浏览器中安装vue.js devtools

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

    <div id="app">
        <input type="text" v-model="num">
        v-model实现双向绑定
        <button v-on:click="num++">点赞</button>
        v-on:click绑定事件，实现自增
        <button v-on:click="cancel">取消</button>
        回到自定义的方法
        
        <h1> {{name}} ,非常帅，有{{num}}个人为他点赞{{hello()}}</h1>
    </div>

    <!-- 导入依赖 -->
    <script src="./node_modules/vue/dist/vue.js"></script>

    <script>
        //1、vue声明式渲染
        let vm = new Vue({ //生成vue对象
            el: "#app",//绑定元素 div id="app"
            data: {  //封装数据
                name: "张三",  // 也可以使用{} //表单中可以取出
                num: 1
            },
            methods:{  //封装方法
                cancel(){
                    this.num -- ;
                },
                hello(){
                    return "1"
                }
            }
        });
        还可以在html控制台 vm.name ,vm 表示 Vue对象的实例

        //2、双向绑定,模型变化，视图变化。反之亦然。
        //3、事件处理

        //v-xx：指令

        //1、创建vue实例，关联页面的模板，将自己的数据（data）渲染到关联的模板，响应式的
        //2、指令来简化对dom的一些操作。
        //3、声明方法来做更复杂的操作。methods里面可以封装方法。

    </script>
</body>

</html>
```

### 组件化

> 在大型应用开发的时候，页面可以划分成很多部分。往往不同的页面，也会有相同的部分。 例如可能会有相同的头部导航。 但是如果每个页面都自开发，这无疑增加了我们开发的成本。
>
> 把页面拆成不同的组件，然后共享组件，避免重复开发。 在vue里，所有的vue实例都是组件，组件其实也是一个vue实例，因此它在定义时也会接收：data、methods、生命周期函等 不同的是组件不会与页面的元素綁定，否则就无法复用了，因此没有el属性。 
>
> 但是组件渲染需要html模板，所以增加了template属性，值就是HTML模板 全局组件定义完毕，任何vue实例都可以直接在HTML中通过组件名称来使用组了 data必须是一个函数，不再是一个对象。

### Vue脚手架

```sh
# 全局安装 Webpack
npm i webpack -g
# 全局安装脚手架
npm i vue-cli -g
# 查看版本 2.9.6
vue -V
# 使用 webpack 模板项目 初始化一个 appname 项目
vue init webpack appname:vue 
# 启动项目，项目中的package.json 中 scripts，代表运行命令
npm start = npm run dev 
# 项目打包
npm run build
```

#### 示例

```sh
$ `vue init webpack app`

? Target directory exists. Continue? (Y/n) y
? Target directory exists. Continue? Yes

? Project name app
? Project description (A Vue.js project)
? Project description A Vue.js project
? Author (lingzhexi <lingzhexi@gmail.com>)
? Author lingzhexi <lingzhexi@gmail.com>
? Vue build (Use arrow keys)
? Vue build standalone
? Install vue-router? (Y/n) `y`
? Install vue-router? Yes
? Use ESLint to lint your code? (Y/n) `n`
? Use ESLint to lint your code? No
? Set up unit tests (Y/n) `n`
? Set up unit tests No
? Setup e2e tests with Nightwatch? (Y/n) `y`
? Setup e2e tests with Nightwatch? Yes
? Should we run `npm install` for you after the project has been created? (recom
? Should we run `npm install` for you after the project has been created? (recom
mended) yarn

   vue-cli · Generated "app".


# Installing project dependencies ...
# ========================

'yarn' is not recognized as an internal or external command,
operable program or batch file.

# Project initialization finished!
# ========================

To get started:

  cd app
  npm run dev

Documentation can be found at https://vuejs-templates.github.io/webpack
```

### 使用element-UI

```sh
# 安装
npm i elemenet-ui -S
```

```js
# 在 main.js 中写入以下内容：
import ElementUI from 'element-ui';
import 'element-ui/lib/theme-chalk/index.css';
Vue.use(ElementUI);
```

### 补充

```sh
# 补充依赖
npm i webpack-dev-server --save-dev
```

